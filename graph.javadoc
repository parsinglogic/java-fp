 * A graph (in the "standard" Computer Science Graph Theory sense).
 *
 * We would have liked to just rattle-off the properties of the types of graph that this implementation supports
 * and move on with our lives - but, on reflection
 * we feel that the terminology is not completely standard
 * so let's spend some time defining exactly what a graph is and some related terms.
 *
 *
 * ### Directed graph
 *
 * Many authors define a **graph** by starting with a **directed graph** like this:
 *
 * > A directed graph or (digraph) is a pair G = (V, A) where
 * >
 * > • `v` is a set of vertices (or nodes), and
 * >
 * > • A ⊆ `v` × `v` is a set of directed edges (or arcs).
 *
 * from ["Carnegie Mellon University, School of Computer Science: Parallel and Sequential Data Structures and Algorithms, Graphs: Definition, Applications, Representation"][cmugraph]
 *
 * So these authors use node/vertex (and edge/arc) interchangeably. Other outhors reserve node and arc for directed graphs ans vertx edge for undirected graphs.
 *
 * For now, we will use vertex and edge.
 *
 * Note that this definition considers the vertices and the edges to be in a **set**.
 *
 * A practical implementation of a graph in Java will have to decide if a graph can contain
 * * any user-defined object as a vertex
 * or
 * * it will define the type of the vertex in some way.
 *
 * For example `Set`s and `ImSet`s can contain objects that have
 * reasonable implementations of hashCode() and equals(). Should graph implementations impose the same restriction?
 *
 * `ImGraph` takes the second approach. To create a vertex in an `ImGraph` you have to supply a key - which must be a "well behaved object" with respect to belonging
 * to a set. However, you can associate any object you want with
 * each key. It does not need to be well-behaved.
 *
 * Each edge, `a`, can be written like this:
 *
 *     a = (u, v)
 *
 * where `u` and `v` are vertices and `a` is a pair - which implies an order to each component.
 *
 * `a` is said to be **incident on** `u` and `v` - also `a` **connects** `a` and `v` and, furthermore, to be **incident from** `u` and **incident to** `v`.
 *
 * Equivalently we say `a` **leaves** `u` and **enters** `v`.
 *
 * `u` is called the **in vertex** for `a` and `v` is the **out vertex**.
 *
 * ### Undirected graph
 *
 * Authors then describe an **undirected graph** by stating that, in an undirected graph, the edges are
 * **unordered** pairs.
 *
 * To indicate this fact we can write an unordered edge `e` like this
 *
 *     e = {u, v}
 *
 * where
 *
 *     {u, v} == {v, u}
 *
 * `e` is said to be **incident on** `u` and `v`.
 *
 * **Mathematical** graph definitions (as opposed to Computer Science definitions) tend to specify that a graph is a **non empty** set of vertices.
 *
 * After this, authors tend to disagree about what the **fundamental** properties are and what they are called but here are some commonly mentioned properties:
 *
 * ### Labeled graph
 *
 * A graph where each vertex has a **label** - that is simply some data. Note that each vertex in an `ImGraph` is uniquely specified by its key. Adding some data
 * to the vertex will not affect its key.
 *
 * ### Edge-labeled graph
 *
 * A graph where each edge has a label - Again this is simply some data. The idea here is that the label is
 * an **enumeration** - to indicate a category/set/type that can be used to identify different types of edges.
 *
 * ### Edge-weighted graph
 *
 * A graph where each edge(AKA edge) has some data associated with it. This data tends to be different in purpose from a label - usually
 * a **value** (rather than an enumeration) that can be used in graph algorithms.
 *
 * ### Self-loop
 *
 * A graph that can have an edge that connects a vertex to itself. This property is considered to only be available for directed graphs.
 *
 * ### Adjacency
 *
 * A vertex `u` is **adjacent** to vertex `v` iff:
 *
 * 1. there exists an edge `(u, v)` (in a directed graph)
 * 2. there exists an edge `{u, v}` (in an undirected graph - recall that {u, v} == {v, u})
 *
 * The adjacent vertices of a vertex are called its **neighbours**.
 *
 *
 * ### Paths
 *
 * A **path** is a non empty list of edges/edges:
 *
 *     [ (a, b), (b, c), (c, d) ... (x, y) ]
 *
 * Where the out vertex of each edge is the in vertex of the next edge in the list.
 *
 * If the edges are not directed then a path is a list of edges where each edge can be written as an ordered pair
 * such that the second vertex of each pair is the first vertex of the next pair in the list.
 *
 * For a directed graph that allows self loops we can have a path that just has one edge in it - and therefore one vertex.
 *
 * The **length** of a path is the number of edges in it.
 *
 * A path's edges will define a list of vertices - by taking the first vertex in each pair and finally adding the second vertex of the last pair. We say that
 * the path **contains** those vertices and each vertex is **in the path**. We may have vertices repeated in this list.
 *
 * A path is **simple** if all its vertices are distinct.
 *
 * For an undirected graph, a path must contain at least two vertices (because self-loops are not allowed).
 *
 * ### Reachability
 *
 * If there exists a path whose first vertex is `u` and whose last vertex is `v` then we say that `v` is **reachable** from `u`.
 *
 * ### Cyclic/acyclic graph
 *
 * A **cycle** is a path where its first and last vertex are equal.
 *
 * A **cyclic graph** is one that contains one or more cycles. An **acyclic graph** is one that has no cycles.
 *
 * ### Connected
 *
 * For an undirected graph, if all of the vertices are reachable from each other, the graph is **connected**, otherwise it is **disconnected**.
 *
 * For a directed graph we use the term **strongly connected** for this property.
 *
 * ## The ImGraph properties
 *
 * Ok - finally - we can describe this `ImGraph` implementation.
 *
 * An ImGraph represents a graph that:
 *
 * 1. is directed
 * 2. is labeled
 * 3. is edge-labeled
 * 5. can have cycles
 * 6. can be disconnected
 * 7. can be empty - ie have no nodes
 *
 * This means that you can't represent an undirected graph ... er .. directly.
 *
 * All the functions have names that use node/arc rather than vertex/edge.
 *
 *
 * Graphs are immutable - each time you add a node or an arc between two nodes, a new graph is created.
 * The `show()` method returns a text representation of the graph in the form of an ascii art diagram.
 *
 * This is an example of a graph with edges labelled `art` or `mod` (and its ascii-art diagram):
 *
 *
 * <p> <img src="{@docRoot}/dev/doc-files/graph-diagrams.png"  width=700/>
 *
 *
 *
 *
 *
 *
 *
 * ## References
 *
 * ["Carnegie Mellon University, School of Computer Science: Parallel and Sequential Data Structures and Algorithms, Mathematical Preliminaries"][cmuprelim]
 *
 * ["Carnegie Mellon University, School of Computer Science: Parallel and Sequential Data Structures and Algorithms, Graphs: Definition, Applications, Representation"][cmugraph]
 *
 * [cmuprelim]: https://www.cs.cmu.edu/afs/cs/academic/class/15210-s15/www/lectures/preliminaries-notes.pdf
 * [cmugraph]: https://www.cs.cmu.edu/afs/cs/academic/class/15210-s15/www/lectures/graph-intro.pdf
 *
 *
